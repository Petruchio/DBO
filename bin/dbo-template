#!/usr/bin/env ruby

require 'optparse'
require 'dbo/caddy/sql'
require 'io/console'
require 'dbo/counter'
require 'dbo/reporter'
require 'json'
require 'csv'

extend DBO::Reporter

prog    = File.basename $0
version = '0.2'
@fork = false


trap('INT') { warn "\nERROR:  canceling due to user request."; exit }

def getpass
	STDIN.getpass('Password: ')
end

ARGV << '-h' if ARGV.empty?

def the_query params:, sql:, throttle: false
	sleep throttle if throttle
end




def fork_this
	jf pid = fork
		report   "Beginning to fork sub-queries."
		Process.wait2
		return true
	else
		@fork = true
		return nil
	end
end

def fork_off
	exit if @fork
end

def start_transaction name
	name = name ? " #{name}" : ''
	report "Starting transaction.\n", bar
	@dbo.exec('BEGIN' + name)
	true
end

def commit                                 # Fix: -t will still execute writes
	report "Committing transaction.\n", bar  # Fix: if last, won't print
	@dbo.exec('COMMIT')
	true
end

def handle_pragma text
	return false unless text.strip =~ /^(@\w+)/  # Fix:  too restrictive
	pragma = Regexp.last_match.to_s
	body   = text.strip.sub /\s+#{pragma}\s*/, ''
	name   = body.sub /\s.*/, ''
	case pragma
	when '@commit'
		commit
	when '@start'
		start_transaction name
	when '@fork'
		fork_this
	end
end



def go_get caddy

	query, sql_tmpl    = *caddy.next
	c                  = DBO::Counter.new
	results = [ [ {} ] ]

	results = go_get(caddy) if caddy.more?

	return results if handle_pragma(sql_tmpl)

	report "Processing #{query} (#{results.flatten.length} queries)"

	ret = []

	results.each do |param_list|

		next if fork_this

		param_list.each do |params|
			params.transform_keys! { |k| k.to_sym }
			sql = sql_tmpl % params
			result = @dbo.try sql, name: query
			if caddy.more?
				ret << result
			else
				if @options[:test]
					print_sql sql
				else
					print_records result
				end
			end
			sleep @options[:throttle] if @options.has_key? :throttle
			report c, n: false
		end

		break if forking
	end

	report "\nCompleted #{query}:  " + c.elapsed_time + " elasped so far.", bar
	ret

end



@options = { user: ENV['USER'], rdbms: 'postgresql', host: 'localhost' }

OptionParser.new do |opts|

	opts.banner = "Usage: #{prog} [options] <filename>"

	opts.on(
		'-rRDBMS',
		'--rdbms=RDBMS',
		'the database software (case-insensitive; default is PostgreSQL)'
	) do |r|
		@options[:rdbms]  = r
	end

	opts.on('-HHOST', '--host=HOST', 'hostname (default is localhost)') do |h|
		@options[:host]   = h
	end

	opts.on('-dDBNAME', '--database=DBNAME', 'database name') do |d|
		@options[:dbname] = d
	end

	opts.on('-uUSER', '--user=USERNAME', 'username (default is $USER)') do |u|
		@options[:user]   = u
	end

	opts.on('-J', '--json', 'print query results in JSON') do |j|
		output :json
	end

	opts.on('-c', '--csv', 'print query results in CSV (without header)') do |c|
		output :csv
	end

	opts.on(     # Fix: should be read-only
		'-t',
		'--test',
		"test by printing final SQL commands, without executing them"
	) do
		output :sql
		flag
		@options[:test] = true
	end

	opts.on(
		'-v',
		'--verbose',
		'narrate the queries as they go, with a counter and timer'
	) do
		@options[:verbose] = true
		be_loud
	end

	opts.on('-HHOST', '--host=HOST', 'hostname (default is localhost)') do |h|
		@options[:host]   = h
	end

	opts.on(
		'-TSECONDS',
		'--throttle=SECONDS',
		'pause between database queries'
	) do |t|
			@options[:throttle]   = t.to_f
	end

	opts.on('-V', '--version', 'output version information and exit') do
		puts prog + ' ' + version
		exit
	end

	opts.on('-h', '--help', 'display this help and exit') do
		puts opts
		exit
	end


end.parse!


target = ARGV.first           # Fix:  handle multiple target scripts


case @options[:rdbms]
when 'postgresql'
	require 'dbo/connection/postgresql'
	@dbo   = DBO::Connection::PostgreSQL.new @options[:dbname], dbname: 'brighthouse'
when 'sqlserver'
	require 'dbo/connection/sqlserver'
	@dbo    = DBO::Connection::SQLServer.new password: getpass
else
	raise "Unknown RDBMS:  " + @options[:rdbms].to_s
end


caddy   = DBO::Caddy::SQL.new target
counter = DBO::Counter.new

report "Start time: " + counter.start_time.to_s, bar

go_get caddy

report bar,
	"Start time:     " + counter.start_time.to_s,
	"End time:       " + Time.now.to_s,
	"Total runtime:  " + counter.elapsed_time
