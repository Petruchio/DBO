#!/usr/bin/env ruby

require 'optparse'
require 'dbo/caddy/sql'
require 'io/console'
require 'dbo/counter'
require 'dbo/reporter'
require 'json'
require 'csv'

extend DBO::Reporter

prog    = File.basename $0
version = '0.2'


trap('INT') { warn "\nERROR:  canceling due to user request."; exit }

def getpass
	STDIN.getpass('Password: ')
end

ARGV << '-h' if ARGV.empty?

def pragma? key    # encapsulate, because the syntax isn't settled
	key =~ /^@/
end

def go_get db_handle, caddy, key_list, stack_level, options
	query      = key_list.pop
	forking    = false
	if query   =~ /^@fork/
		forking  = true
		query    = key_list.pop
		raise "two consecutive fork directivess" if query == '@fork'
		report "Beginning to fork sub-queries."
	end
	sql_tmpl   = caddy[query]
	c          = DBO::Counter.new
	ret        = []
	results_of_queries = [ [ {} ] ]

	unless key_list.empty?
		results_of_queries = go_get(db_handle, caddy, key_list, stack_level + 1, options)
	end

	if query =~ /^@begin/
		report "Starting transaction.\n", bar
		ret << db_handle.exec('BEGIN')
		return results_of_queries
	elsif query =~ /^@commit/                 # Fix: if last, won't print
		report "Committing transaction.\n", bar # Fix: -t will still execute writes
		ret << db_handle.exec('COMMIT')
		return results_of_queries
	end

	report "Processing #{query} (#{results_of_queries.flatten.length} queries)"

	results_of_queries.each do |param_list|
		if forking
			if pid = fork
				Process.wait2
				next
			end
		end
		param_list.each do |params|
			params.transform_keys! { |k| k.to_sym }
			sql = sql_tmpl % params
			if( options[:test] && stack_level == 1 )
				print_sql sql
			else
				begin
					if stack_level == 1
						print_records db_handle.exec(sql)
					else
						ret << db_handle.exec(sql)
					end
				rescue PG::UndefinedColumn => e
					db_handle.fail e, "Unknown column in #{query}.", sql
				rescue PG::UndefinedTable => e
					db_handle.fail e, "Unknown relation in #{query}.", sql
				rescue PG::SyntaxError => e
					db_handle.fail e, "Syntax error in #{query}.", sql
				end
				sleep options[:throttle] if options.has_key? :throttle
			end
			report c, n: false
		end
		break if forking
	end

	report "\nCompleted #{query}:  " + c.elapsed_time + " elasped so far.", bar
	ret
end



options = { user: ENV['USER'], rdbms: 'postgresql', host: 'localhost' }

OptionParser.new do |opts|

	opts.banner = "Usage: #{prog} [options] <filename>"

	opts.on(
		'-rRDBMS',
		'--rdbms=RDBMS',
		'the database software (case-insensitive; default is PostgreSQL)'
	) do |r|
		options[:rdbms]  = r
	end

	opts.on('-HHOST', '--host=HOST', 'hostname (default is localhost)') do |h|
		options[:host]   = h
	end

	opts.on('-dDBNAME', '--database=DBNAME', 'database name') do |d|
		options[:dbname] = d
	end

	opts.on('-uUSER', '--user=USERNAME', 'username (default is $USER)') do |u|
		options[:user]   = u
	end

	opts.on('-J', '--json', 'print query results in JSON') do |j|
		output :json
	end

	opts.on('-c', '--csv', 'print query results in CSV (without header)') do |c|
		output :csv
	end

	opts.on(     # Fix: should be read-only
		'-t',
		'--test',
		"test by printing final SQL commands, without executing them"
	) do
		output :sql
		flag
		options[:test] = true
	end

	opts.on(
		'-v',
		'--verbose',
		'narrate the queries as they go, with a counter and timer'
	) do
		options[:verbose] = true
		be_loud
	end

	opts.on('-HHOST', '--host=HOST', 'hostname (default is localhost)') do |h|
		options[:host]   = h
	end

	opts.on(
		'-TSECONDS',
		'--throttle=SECONDS',
		'pause between database queries'
	) do |t|
			options[:throttle]   = t.to_f
	end

	opts.on('-V', '--version', 'output version information and exit') do
		puts prog + ' ' + version
		exit
	end

	opts.on('-h', '--help', 'display this help and exit') do
		puts opts
		exit
	end


end.parse!


target = ARGV.first           # Fix:  handle multiple target scripts


case options[:rdbms]
when 'postgresql'
	require 'dbo/connection/postgresql'
	dbo   = DBO::Connection::PostgreSQL.new options[:dbname], dbname: 'brighthouse'
when 'sqlserver'
	require 'dbo/connection/sqlserver'
	dbo    = DBO::Connection::SQLServer.new password: getpass
else
	raise "Unknown RDBMS:  " + options[:rdbms].to_s
end


caddy   = DBO::Caddy::SQL.new target
counter = DBO::Counter.new

report "Start time: " + counter.start_time.to_s, bar

go_get( dbo, caddy, caddy.keys, 1, options )

report bar,
	"Start time:     " + counter.start_time.to_s,
	"End time:       " + Time.now.to_s,
	"Total runtime:  " + counter.elapsed_time
